% Generated by Sphinx.
\def\sphinxdocclass{report}
\documentclass[letterpaper,10pt,english]{sphinxmanual}
\usepackage[utf8]{inputenc}
\DeclareUnicodeCharacter{00A0}{\nobreakspace}
\usepackage{cmap}
\usepackage[T1]{fontenc}
\usepackage{babel}
\usepackage{times}
\usepackage[Bjarne]{fncychap}
\usepackage{longtable}
\usepackage{sphinx}
\usepackage{multirow}


\title{Implementation Documentation}
\date{November 22, 2013}
\release{}
\author{Dieuwke Hupkes}
\newcommand{\sphinxlogo}{}
\renewcommand{\releasename}{Release}
\makeindex

\makeatletter
\def\PYG@reset{\let\PYG@it=\relax \let\PYG@bf=\relax%
    \let\PYG@ul=\relax \let\PYG@tc=\relax%
    \let\PYG@bc=\relax \let\PYG@ff=\relax}
\def\PYG@tok#1{\csname PYG@tok@#1\endcsname}
\def\PYG@toks#1+{\ifx\relax#1\empty\else%
    \PYG@tok{#1}\expandafter\PYG@toks\fi}
\def\PYG@do#1{\PYG@bc{\PYG@tc{\PYG@ul{%
    \PYG@it{\PYG@bf{\PYG@ff{#1}}}}}}}
\def\PYG#1#2{\PYG@reset\PYG@toks#1+\relax+\PYG@do{#2}}

\expandafter\def\csname PYG@tok@gd\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.63,0.00,0.00}{##1}}}
\expandafter\def\csname PYG@tok@gu\endcsname{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.50,0.00,0.50}{##1}}}
\expandafter\def\csname PYG@tok@gt\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.00,0.27,0.87}{##1}}}
\expandafter\def\csname PYG@tok@gs\endcsname{\let\PYG@bf=\textbf}
\expandafter\def\csname PYG@tok@gr\endcsname{\def\PYG@tc##1{\textcolor[rgb]{1.00,0.00,0.00}{##1}}}
\expandafter\def\csname PYG@tok@cm\endcsname{\let\PYG@it=\textit\def\PYG@tc##1{\textcolor[rgb]{0.25,0.50,0.56}{##1}}}
\expandafter\def\csname PYG@tok@vg\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.73,0.38,0.84}{##1}}}
\expandafter\def\csname PYG@tok@m\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.13,0.50,0.31}{##1}}}
\expandafter\def\csname PYG@tok@mh\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.13,0.50,0.31}{##1}}}
\expandafter\def\csname PYG@tok@cs\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.25,0.50,0.56}{##1}}\def\PYG@bc##1{\setlength{\fboxsep}{0pt}\colorbox[rgb]{1.00,0.94,0.94}{\strut ##1}}}
\expandafter\def\csname PYG@tok@ge\endcsname{\let\PYG@it=\textit}
\expandafter\def\csname PYG@tok@vc\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.73,0.38,0.84}{##1}}}
\expandafter\def\csname PYG@tok@il\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.13,0.50,0.31}{##1}}}
\expandafter\def\csname PYG@tok@go\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.20,0.20,0.20}{##1}}}
\expandafter\def\csname PYG@tok@cp\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.00,0.44,0.13}{##1}}}
\expandafter\def\csname PYG@tok@gi\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.00,0.63,0.00}{##1}}}
\expandafter\def\csname PYG@tok@gh\endcsname{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.00,0.00,0.50}{##1}}}
\expandafter\def\csname PYG@tok@ni\endcsname{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.84,0.33,0.22}{##1}}}
\expandafter\def\csname PYG@tok@nl\endcsname{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.00,0.13,0.44}{##1}}}
\expandafter\def\csname PYG@tok@nn\endcsname{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.05,0.52,0.71}{##1}}}
\expandafter\def\csname PYG@tok@no\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.38,0.68,0.84}{##1}}}
\expandafter\def\csname PYG@tok@na\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.25,0.44,0.63}{##1}}}
\expandafter\def\csname PYG@tok@nb\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.00,0.44,0.13}{##1}}}
\expandafter\def\csname PYG@tok@nc\endcsname{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.05,0.52,0.71}{##1}}}
\expandafter\def\csname PYG@tok@nd\endcsname{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.33,0.33,0.33}{##1}}}
\expandafter\def\csname PYG@tok@ne\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.00,0.44,0.13}{##1}}}
\expandafter\def\csname PYG@tok@nf\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.02,0.16,0.49}{##1}}}
\expandafter\def\csname PYG@tok@si\endcsname{\let\PYG@it=\textit\def\PYG@tc##1{\textcolor[rgb]{0.44,0.63,0.82}{##1}}}
\expandafter\def\csname PYG@tok@s2\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.25,0.44,0.63}{##1}}}
\expandafter\def\csname PYG@tok@vi\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.73,0.38,0.84}{##1}}}
\expandafter\def\csname PYG@tok@nt\endcsname{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.02,0.16,0.45}{##1}}}
\expandafter\def\csname PYG@tok@nv\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.73,0.38,0.84}{##1}}}
\expandafter\def\csname PYG@tok@s1\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.25,0.44,0.63}{##1}}}
\expandafter\def\csname PYG@tok@gp\endcsname{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.78,0.36,0.04}{##1}}}
\expandafter\def\csname PYG@tok@sh\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.25,0.44,0.63}{##1}}}
\expandafter\def\csname PYG@tok@ow\endcsname{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.00,0.44,0.13}{##1}}}
\expandafter\def\csname PYG@tok@sx\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.78,0.36,0.04}{##1}}}
\expandafter\def\csname PYG@tok@bp\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.00,0.44,0.13}{##1}}}
\expandafter\def\csname PYG@tok@c1\endcsname{\let\PYG@it=\textit\def\PYG@tc##1{\textcolor[rgb]{0.25,0.50,0.56}{##1}}}
\expandafter\def\csname PYG@tok@kc\endcsname{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.00,0.44,0.13}{##1}}}
\expandafter\def\csname PYG@tok@c\endcsname{\let\PYG@it=\textit\def\PYG@tc##1{\textcolor[rgb]{0.25,0.50,0.56}{##1}}}
\expandafter\def\csname PYG@tok@mf\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.13,0.50,0.31}{##1}}}
\expandafter\def\csname PYG@tok@err\endcsname{\def\PYG@bc##1{\setlength{\fboxsep}{0pt}\fcolorbox[rgb]{1.00,0.00,0.00}{1,1,1}{\strut ##1}}}
\expandafter\def\csname PYG@tok@kd\endcsname{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.00,0.44,0.13}{##1}}}
\expandafter\def\csname PYG@tok@ss\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.32,0.47,0.09}{##1}}}
\expandafter\def\csname PYG@tok@sr\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.14,0.33,0.53}{##1}}}
\expandafter\def\csname PYG@tok@mo\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.13,0.50,0.31}{##1}}}
\expandafter\def\csname PYG@tok@mi\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.13,0.50,0.31}{##1}}}
\expandafter\def\csname PYG@tok@kn\endcsname{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.00,0.44,0.13}{##1}}}
\expandafter\def\csname PYG@tok@o\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.40,0.40,0.40}{##1}}}
\expandafter\def\csname PYG@tok@kr\endcsname{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.00,0.44,0.13}{##1}}}
\expandafter\def\csname PYG@tok@s\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.25,0.44,0.63}{##1}}}
\expandafter\def\csname PYG@tok@kp\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.00,0.44,0.13}{##1}}}
\expandafter\def\csname PYG@tok@w\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.73,0.73,0.73}{##1}}}
\expandafter\def\csname PYG@tok@kt\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.56,0.13,0.00}{##1}}}
\expandafter\def\csname PYG@tok@sc\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.25,0.44,0.63}{##1}}}
\expandafter\def\csname PYG@tok@sb\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.25,0.44,0.63}{##1}}}
\expandafter\def\csname PYG@tok@k\endcsname{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.00,0.44,0.13}{##1}}}
\expandafter\def\csname PYG@tok@se\endcsname{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.25,0.44,0.63}{##1}}}
\expandafter\def\csname PYG@tok@sd\endcsname{\let\PYG@it=\textit\def\PYG@tc##1{\textcolor[rgb]{0.25,0.44,0.63}{##1}}}

\def\PYGZbs{\char`\\}
\def\PYGZus{\char`\_}
\def\PYGZob{\char`\{}
\def\PYGZcb{\char`\}}
\def\PYGZca{\char`\^}
\def\PYGZam{\char`\&}
\def\PYGZlt{\char`\<}
\def\PYGZgt{\char`\>}
\def\PYGZsh{\char`\#}
\def\PYGZpc{\char`\%}
\def\PYGZdl{\char`\$}
\def\PYGZhy{\char`\-}
\def\PYGZsq{\char`\'}
\def\PYGZdq{\char`\"}
\def\PYGZti{\char`\~}
% for compatibility with earlier versions
\def\PYGZat{@}
\def\PYGZlb{[}
\def\PYGZrb{]}
\makeatother

\begin{document}

\maketitle
\tableofcontents
\phantomsection\label{index::doc}


Contents:


\chapter{alignments Module}
\label{alignments:module-alignments}\label{alignments::doc}\label{alignments:welcome-to-implementation-s-documentation}\label{alignments:alignments-module}\index{alignments (module)}
Module for processing alignments. This module contains three classes. Running alignments.py
will give a demonstration of te functionality of the classes.
\index{Alignments (class in alignments)}

\begin{fulllineitems}
\phantomsection\label{alignments:alignments.Alignments}\pysiglinewithargsret{\strong{class }\code{alignments.}\bfcode{Alignments}}{\emph{links}, \emph{source}, \emph{target='`}}{}
A class that represents alignments. Important methods in this class
compute the monolingual source phrases according to this alignment,
generate all rules or all maximally recursive rules that are
associated with the alignment and generate a dictionary representing
all trees that are generated with this rules in a compact fashion.

Construct a new alignment object with the alignment links
given by `links', the sourcesentence given by `source', and 
possibly a target sentence `target'. Construct a set-representation
of the alignment, and compute a lexical dictionary describing
the spans of the words.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\textbf{links} -- a string of the form `0-1 2-1 ...' representing
the alignment links. Word numbering starts at 0.

\item {} 
\textbf{source} -- A string representing the source sentence.

\item {} 
\textbf{target} -- A string representing the target sentence.

\end{itemize}

\end{description}\end{quote}

Class is initialized with a string representation of
the alignment that starts counting at 0 of the form 
`0-1 2-1 ...' and the sentence the alignment represents.
During intialization, a set-representation of the alignment
is created.
\index{HAT\_dict() (alignments.Alignments method)}

\begin{fulllineitems}
\phantomsection\label{alignments:alignments.Alignments.HAT_dict}\pysiglinewithargsret{\bfcode{HAT\_dict}}{\emph{labels=\{\}}}{}
Transform all HATrules into a dictionary that memory
efficiently represents the entire forest of HATs.
As a HAT\_dict uniquely represents a HATforest, the labels
of all spans should be unique avoid amibuity.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\textbf{labels} -- A dictionary assigning labels to spans.

\item[{Returns}] \leavevmode
A dictionary that represents the HATforest, by describing for
every allowed span what is allowed expansions are. Entries are of
the form \{lhs: {[}(rhs\_11,...,rhs\_1m),...,(rhs\_n1,...,rhs\_nk){]}

\end{description}\end{quote}

\end{fulllineitems}

\index{\_links\_fromE() (alignments.Alignments method)}

\begin{fulllineitems}
\phantomsection\label{alignments:alignments.Alignments._links_fromE}\pysiglinewithargsret{\bfcode{\_links\_fromE}}{}{}
Precompute values for the function
E\_c(j) = {\color{red}\bfseries{}\textbar{}\{(i',j')\textbackslash{}in A \textbar{} j' =\textless{} j\}\textbar{}}.

\end{fulllineitems}

\index{\_links\_fromF() (alignments.Alignments method)}

\begin{fulllineitems}
\phantomsection\label{alignments:alignments.Alignments._links_fromF}\pysiglinewithargsret{\bfcode{\_links\_fromF}}{}{}
Precompute values for the function
F\_c(j) = {\color{red}\bfseries{}\textbar{}\{(i',j')\textbackslash{}in A \textbar{} i' =\textless{} i\}\textbar{}}.

\end{fulllineitems}

\index{\_maxspan() (alignments.Alignments method)}

\begin{fulllineitems}
\phantomsection\label{alignments:alignments.Alignments._maxspan}\pysiglinewithargsret{\bfcode{\_maxspan}}{\emph{(x}, \emph{y)}}{}
Returns the maximum position on the target side
that are linked to positions {[}x,y{]}.

\end{fulllineitems}

\index{\_minspan() (alignments.Alignments method)}

\begin{fulllineitems}
\phantomsection\label{alignments:alignments.Alignments._minspan}\pysiglinewithargsret{\bfcode{\_minspan}}{\emph{(x}, \emph{y)}}{}
Returns the minimum position on the target side
that are linked to positions {[}x,y{]}.

\end{fulllineitems}

\index{agreement() (alignments.Alignments method)}

\begin{fulllineitems}
\phantomsection\label{alignments:alignments.Alignments.agreement}\pysiglinewithargsret{\bfcode{agreement}}{\emph{tree}}{}
Output what percentage of the nodes of an inputted tree
are consistent with the alignment.
:param tree:            An nltk tree object.
:return:        a float that describes the percentage of the nodes
\begin{quote}

of tree that were nodes according to the alignment.
\end{quote}

\end{fulllineitems}

\index{compute\_phrases() (alignments.Alignments method)}

\begin{fulllineitems}
\phantomsection\label{alignments:alignments.Alignments.compute_phrases}\pysiglinewithargsret{\bfcode{compute\_phrases}}{}{}
Return a list with all source phrases of the alignment.
Similar to Alignments.spans, but returns a list rather
than a generator, and does not include all one-length units.
\begin{quote}\begin{description}
\item[{Returns}] \leavevmode
A list with all valid source phrases

\end{description}\end{quote}

\end{fulllineitems}

\index{consistent\_labels() (alignments.Alignments method)}

\begin{fulllineitems}
\phantomsection\label{alignments:alignments.Alignments.consistent_labels}\pysiglinewithargsret{\bfcode{consistent\_labels}}{\emph{labels}, \emph{label\_dict}}{}
Measures the consistency of the alignment with a dictionary
that assigns labels to spans.
Outputs a dictionary with labels, how often
they occurred in the input set and how often they were preserved.
Ignore word-labels from dep-parse that end in -h.

\end{fulllineitems}

\index{hat\_rules() (alignments.Alignments method)}

\begin{fulllineitems}
\phantomsection\label{alignments:alignments.Alignments.hat_rules}\pysiglinewithargsret{\bfcode{hat\_rules}}{\emph{prob\_function}, \emph{args=}\optional{}, \emph{labels=\{\}}}{}
Return a generator with all rules of a PCFG
uniquely generating all \emph{hierarchical} alignment trees. The rules
are assigned probabilities using the input probability function, args
are the arguments of these function.

The rules are computed by transforming the alignment into a set
of Node objects and links between them that together constitute a
graph whose edges correspond to valid spans and partial
sets, and using the shortest\_path function of the Node class.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\textbf{prob\_function} -- A probability function from the Rule class, according to which
probabilities should be assigned.

\item {} 
\textbf{args} -- The arguments the probability function needs.

\item {} 
\textbf{labels} (\emph{A dictionary assigning labels to spans.}) -- The labels that should be assigned to the spans.

\end{itemize}

\end{description}\end{quote}

\end{fulllineitems}

\index{lex\_dict() (alignments.Alignments method)}

\begin{fulllineitems}
\phantomsection\label{alignments:alignments.Alignments.lex_dict}\pysiglinewithargsret{\bfcode{lex\_dict}}{}{}
Use self.sentence to create a lexical dictionary
that assigns lexical items to spans.
:return: A dictionary \{(0,1) : word1,..,(n-1,n): wordn\}

\end{fulllineitems}

\index{lexrules() (alignments.Alignments method)}

\begin{fulllineitems}
\phantomsection\label{alignments:alignments.Alignments.lexrules}\pysiglinewithargsret{\bfcode{lexrules}}{\emph{labels=\{\}}}{}
Returns an generator with the terminal rules
of the grammar. (i.e., the {\color{red}\bfseries{}{}`}lexicon', that tells 
you the span corresponding to a word).
If labels are provided for the spans, the rules
will be labelled accordingly.
\begin{quote}\begin{description}
\end{description}\end{quote}

\end{fulllineitems}

\index{make\_set() (alignments.Alignments method)}

\begin{fulllineitems}
\phantomsection\label{alignments:alignments.Alignments.make_set}\pysiglinewithargsret{\bfcode{make\_set}}{\emph{alignment}}{}
Return a set with all alignment links, and keep track of 
the length of source and target sentence.
Output a warning when alignment and sentence do not have
the same number of words.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\textbf{alignment} -- A string representing the alignment, as was passed during
initialisation

\end{description}\end{quote}

\end{fulllineitems}

\index{percentage\_labelled() (alignments.Alignments method)}

\begin{fulllineitems}
\phantomsection\label{alignments:alignments.Alignments.percentage_labelled}\pysiglinewithargsret{\bfcode{percentage\_labelled}}{\emph{labels}}{}
Output which percentage of the spans in the alignment
are labelled by the set of inputted labels.
:return:        total, labelled

\end{fulllineitems}

\index{prune\_production() (alignments.Alignments method)}

\begin{fulllineitems}
\phantomsection\label{alignments:alignments.Alignments.prune_production}\pysiglinewithargsret{\bfcode{prune\_production}}{\emph{rule}, \emph{lex\_dict}}{}
Replace all leafnodes that do not constitute
a valid source phrase with the lexical item the
leafnode dominates.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\textbf{lex\_dict} -- a dictionary with spans as keys, and the corresponding
lexical items as values.

\item[{Returns}] \leavevmode
a Rule object in which all nodes are either valid
source spans or lexical items.

\end{description}\end{quote}

\end{fulllineitems}

\index{rules() (alignments.Alignments method)}

\begin{fulllineitems}
\phantomsection\label{alignments:alignments.Alignments.rules}\pysiglinewithargsret{\bfcode{rules}}{\emph{prob\_function}, \emph{args}, \emph{labels=\{\}}}{}
Returns a generator with all rules of a PCFG
uniquely generating all alignment trees. Rule
probabilities are assigned according to specified
input probability function, args should contain a list
of arguments for this function.

The rules are computed by transforming the alignment into
a graph whose edges correspond to valid spans and partial
sets and using the path function of the Node class.
This function is not as extensively tested as the hat\_rules function,
as it is rarely used for computational issues.

\end{fulllineitems}

\index{spans() (alignments.Alignments method)}

\begin{fulllineitems}
\phantomsection\label{alignments:alignments.Alignments.spans}\pysiglinewithargsret{\bfcode{spans}}{}{}
Return all a generator with all valid source side 
spans that are part of a phrase pair, and all one-length
units that are necessarily part of a tree describing the
translation.
Contrary to the convention, also unaligned sequences
of words are allowed as spans.

Spans are computed using the first shift-reduce algorithm 
presented in Chang \& Gildea (2006). This is not the most
efficient algorithm to compute phrase pairs.

\end{fulllineitems}

\index{texstring() (alignments.Alignments method)}

\begin{fulllineitems}
\phantomsection\label{alignments:alignments.Alignments.texstring}\pysiglinewithargsret{\bfcode{texstring}}{}{}
Generate latexcode that generates a visual representation
of the alignment.

\end{fulllineitems}


\end{fulllineitems}

\index{HAT\_demo() (in module alignments)}

\begin{fulllineitems}
\phantomsection\label{alignments:alignments.HAT_demo}\pysiglinewithargsret{\code{alignments.}\bfcode{HAT\_demo}}{}{}
Demonstration 3. Simple one to many alignment, HATfunctionality.

\end{fulllineitems}

\index{Node (class in alignments)}

\begin{fulllineitems}
\phantomsection\label{alignments:alignments.Node}\pysiglinewithargsret{\strong{class }\code{alignments.}\bfcode{Node}}{\emph{value}}{}
Defines a node in a directed graph.
You can add edges from this node to
other nodes by using link\_to. The
paths\_to method calculates all paths
from this node to the given node.
The Node class is used to represent alignments as
graphs.

Initializes a new node; value
can be used for representation
\index{link\_to() (alignments.Node method)}

\begin{fulllineitems}
\phantomsection\label{alignments:alignments.Node.link_to}\pysiglinewithargsret{\bfcode{link\_to}}{\emph{node}}{}
Add a directed edge from this node to
the given node.
:type node:     A Node object.

\end{fulllineitems}

\index{paths\_to() (alignments.Node method)}

\begin{fulllineitems}
\phantomsection\label{alignments:alignments.Node.paths_to}\pysiglinewithargsret{\bfcode{paths\_to}}{\emph{node}}{}
Returns a generator that calculates all
paths to the given node. These paths
are calculated recursively.
:type node:     a Node object

\end{fulllineitems}

\index{remove\_link() (alignments.Node method)}

\begin{fulllineitems}
\phantomsection\label{alignments:alignments.Node.remove_link}\pysiglinewithargsret{\bfcode{remove\_link}}{\emph{node}}{}
Remove the edge to this node, if
present
:type node: A Node object.

\end{fulllineitems}

\index{shortest\_paths\_to() (alignments.Node method)}

\begin{fulllineitems}
\phantomsection\label{alignments:alignments.Node.shortest_paths_to}\pysiglinewithargsret{\bfcode{shortest\_paths\_to}}{\emph{node}}{}
Finds all shortest paths from current node
to node using an adapted Dijkstra algorithm
starting from the end.
The function also stores paths that can be
used for later(i.e paths longer than 1
from self to intermediate nodes).
:type node:     A Node object.

\end{fulllineitems}


\end{fulllineitems}

\index{Rule (class in alignments)}

\begin{fulllineitems}
\phantomsection\label{alignments:alignments.Rule}\pysiglinewithargsret{\strong{class }\code{alignments.}\bfcode{Rule}}{\emph{root}, \emph{path}, \emph{labels=\{\}}}{}
Defines a rule from one span to a set
of consecutive spans which's union
forms it.

A string representation is provided for convenient
displaying.

Initialize a new rule as its root span
and the path in the graph (consisting
of an array of nodes) that it produces.
Labels can be provided to annotate the spans
of a rule.
:param root:    The rootspan of the node.
:type path:             A Waypoint.
:type labels:   A dictionary assigning labels to spans.
\index{\_lhs() (alignments.Rule method)}

\begin{fulllineitems}
\phantomsection\label{alignments:alignments.Rule._lhs}\pysiglinewithargsret{\bfcode{\_lhs}}{\emph{labels}}{}
Create the left hand sides of the rule
and set as an attribute.

\end{fulllineitems}

\index{\_rhs() (alignments.Rule method)}

\begin{fulllineitems}
\phantomsection\label{alignments:alignments.Rule._rhs}\pysiglinewithargsret{\bfcode{\_rhs}}{\emph{labels}}{}
Create the right hand sight of the rule
and set as attribute.

\end{fulllineitems}

\index{\_str() (alignments.Rule method)}

\begin{fulllineitems}
\phantomsection\label{alignments:alignments.Rule._str}\pysiglinewithargsret{\bfcode{\_str}}{\emph{rhs}}{}
\end{fulllineitems}

\index{lhs() (alignments.Rule method)}

\begin{fulllineitems}
\phantomsection\label{alignments:alignments.Rule.lhs}\pysiglinewithargsret{\bfcode{lhs}}{}{}
Return the left hand side of the rule.
:type return:   nltk.Nonterminal object.

\end{fulllineitems}

\index{probability\_labels() (alignments.Rule method)}

\begin{fulllineitems}
\phantomsection\label{alignments:alignments.Rule.probability_labels}\pysiglinewithargsret{\bfcode{probability\_labels}}{\emph{labels}}{}
Compute the probability of a rule according
to how many of the nodes it generates can
be labelled according to a set of given
labels.
:param labels:  A list containing a dictionary that
\begin{quote}

assigns labels to spans.
\end{quote}

\end{fulllineitems}

\index{probability\_spanrels() (alignments.Rule method)}

\begin{fulllineitems}
\phantomsection\label{alignments:alignments.Rule.probability_spanrels}\pysiglinewithargsret{\bfcode{probability\_spanrels}}{\emph{span\_relations}}{}
Compute the probability of a rule according to
how many span\_relations it makes true.
:param span\_relations:  A list containing a dictionary
\begin{quote}

which describes which
spanrelations are desired.
\end{quote}

\end{fulllineitems}

\index{rank() (alignments.Rule method)}

\begin{fulllineitems}
\phantomsection\label{alignments:alignments.Rule.rank}\pysiglinewithargsret{\bfcode{rank}}{}{}
Return the rank of a rule.

\end{fulllineitems}

\index{rhs() (alignments.Rule method)}

\begin{fulllineitems}
\phantomsection\label{alignments:alignments.Rule.rhs}\pysiglinewithargsret{\bfcode{rhs}}{}{}
Return the right hand side of the rule.
:type return:   a tuple with nltk.Nonterminal objects

\end{fulllineitems}

\index{uniform\_probability() (alignments.Rule method)}

\begin{fulllineitems}
\phantomsection\label{alignments:alignments.Rule.uniform_probability}\pysiglinewithargsret{\bfcode{uniform\_probability}}{\emph{args=}\optional{}}{}
Set probability to 1.

\end{fulllineitems}


\end{fulllineitems}

\index{Waypoint (class in alignments)}

\begin{fulllineitems}
\phantomsection\label{alignments:alignments.Waypoint}\pysiglinewithargsret{\strong{class }\code{alignments.}\bfcode{Waypoint}}{\emph{node}, \emph{link=None}}{}
Defines a waypoint in a one-directional path. The class
Waypoint is used in the representation of paths. Multiple
paths can be saved more memory efficient as path arrays
can be shared between paths. As they contain link to other
Waypoints, Waypoints can represent paths as linked lists.

Create a waypoint object.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\textbf{node} (\emph{A Node Object.}) -- The node it represents.

\item {} 
\textbf{link} (\emph{A Waypoint object.}) -- A link to the next waypoint.

\end{itemize}

\end{description}\end{quote}

\end{fulllineitems}

\index{demo\_basic() (in module alignments)}

\begin{fulllineitems}
\phantomsection\label{alignments:alignments.demo_basic}\pysiglinewithargsret{\code{alignments.}\bfcode{demo\_basic}}{}{}
Demonstration 1, basic monotone one-to-one alignment.

\end{fulllineitems}

\index{demo\_basic2() (in module alignments)}

\begin{fulllineitems}
\phantomsection\label{alignments:alignments.demo_basic2}\pysiglinewithargsret{\code{alignments.}\bfcode{demo\_basic2}}{}{}
Demonstration 2. Simple one-to-many alignment.

\end{fulllineitems}

\index{demos() (in module alignments)}

\begin{fulllineitems}
\phantomsection\label{alignments:alignments.demos}\pysiglinewithargsret{\code{alignments.}\bfcode{demos}}{}{}
\end{fulllineitems}



\chapter{dependencies Module}
\label{constituencies:module-constituencies}\label{constituencies:dependencies-module}\label{constituencies::doc}\index{constituencies (module)}\index{ConstituencyTree (class in constituencies)}

\begin{fulllineitems}
\phantomsection\label{constituencies:constituencies.ConstituencyTree}\pysiglinewithargsret{\strong{class }\code{constituencies.}\bfcode{ConstituencyTree}}{\emph{tree}, \emph{sentence=False}}{}
A class representing a constuency tree. The classes uses
the nltk class nltk.Tree, but adds some functionality that
is useful with respects to alignments.

Create a ConstituencyTree object.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\textbf{tree} (\emph{str or nltk.Tree object.}) -- A constituency tree.

\item {} 
\textbf{sentence} -- The sentence that the leafnodes of the tree constitute.

\end{itemize}

\end{description}\end{quote}
\index{branching\_factor() (constituencies.ConstituencyTree method)}

\begin{fulllineitems}
\phantomsection\label{constituencies:constituencies.ConstituencyTree.branching_factor}\pysiglinewithargsret{\bfcode{branching\_factor}}{\emph{branching\_dict=\{\}}}{}
Return a dictionary that summaries the different 
branching factors of the trees. If initialised with
a dictionary, update this dictionary with the
valeus of the current tree.

\end{fulllineitems}

\index{nr\_of\_nonterminals() (constituencies.ConstituencyTree method)}

\begin{fulllineitems}
\phantomsection\label{constituencies:constituencies.ConstituencyTree.nr_of_nonterminals}\pysiglinewithargsret{\bfcode{nr\_of\_nonterminals}}{}{}
Return the number of nonterminals in self.tree.

\end{fulllineitems}

\index{phrases\_consistent() (constituencies.ConstituencyTree method)}

\begin{fulllineitems}
\phantomsection\label{constituencies:constituencies.ConstituencyTree.phrases_consistent}\pysiglinewithargsret{\bfcode{phrases\_consistent}}{\emph{subtree}, \emph{startpos}, \emph{phrase\_list}}{}
Return the number of non-terminal nodes in the tree
that occur in the provided list of phrases.
:param subtree:         A subtree of self.tree.
:param startpos:        The left-most word position the subtree dominates.
:param phrase\_list:     A list of allowed phrases.
:return:        the number of nodes in the tree that is in phrase\_list.

\end{fulllineitems}

\index{reconstruct\_sentence() (constituencies.ConstituencyTree method)}

\begin{fulllineitems}
\phantomsection\label{constituencies:constituencies.ConstituencyTree.reconstruct_sentence}\pysiglinewithargsret{\bfcode{reconstruct\_sentence}}{}{}
Reconstruct the sentence from the leaf nodes of the
tree. If a sentence was passed in initalisation, return
this sentence.
:type return:   str

\end{fulllineitems}

\index{root\_span() (constituencies.ConstituencyTree method)}

\begin{fulllineitems}
\phantomsection\label{constituencies:constituencies.ConstituencyTree.root_span}\pysiglinewithargsret{\bfcode{root\_span}}{\emph{subtree}, \emph{startpos}}{}
Recursively compute the span a node covers
:param subtree:         a subtree of self.tree
:param startpos:        the first position the subtree dominates

\end{fulllineitems}


\end{fulllineitems}

\index{demo() (in module constituencies)}

\begin{fulllineitems}
\phantomsection\label{constituencies:constituencies.demo}\pysiglinewithargsret{\code{constituencies.}\bfcode{demo}}{}{}
\end{fulllineitems}



\chapter{dependencies Module}
\label{dependencies:dependencies-module}\label{dependencies::doc}\label{dependencies:module-dependencies}\index{dependencies (module)}\index{Dependencies (class in dependencies)}

\begin{fulllineitems}
\phantomsection\label{dependencies:dependencies.Dependencies}\pysiglinewithargsret{\strong{class }\code{dependencies.}\bfcode{Dependencies}}{\emph{dependency\_list}, \emph{sentence=False}}{}
A class representing the dependencies of a sentence in a dictionary.
The dependencies are created from a list with dependencies formatted
like the stanford dependency parses.

Create a Dependencies object, based on the passed dependency list.
If no sentence is passed, the sentence is reconstructed from the
dependency list, leaving gaps for items that were not included.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\textbf{dependency\_list} -- A list with dependencies of the form 
reltype(head-pos\_head, dependent-pos\_dependent)
min(pos-dependent) = 1

\item[{Returns}] \leavevmode
A dictionaries with entries of the form pos\_head: {[}pos\_dependent, reltype{]}

\end{description}\end{quote}
\index{POStag() (dependencies.Dependencies method)}

\begin{fulllineitems}
\phantomsection\label{dependencies:dependencies.Dependencies.POStag}\pysiglinewithargsret{\bfcode{POStag}}{\emph{word}}{}
Find a postag for a word.

\end{fulllineitems}

\index{SAMT\_labels() (dependencies.Dependencies method)}

\begin{fulllineitems}
\phantomsection\label{dependencies:dependencies.Dependencies.SAMT_labels}\pysiglinewithargsret{\bfcode{SAMT\_labels}}{}{}
Create SAMT-style labels based on the basic dependency labels
created in dependency\_labels. The order if precedence is as follows:
\begin{itemize}
\item {} 
Basic labels

\item {} 
labels A + B, where A and B are basic labels

\item {} 
labels A/B or AB where A and B are basic labels

\item {} 
labels A + B + C where A,B and C are basic labels

\end{itemize}

\end{fulllineitems}

\index{annotate\_span() (dependencies.Dependencies method)}

\begin{fulllineitems}
\phantomsection\label{dependencies:dependencies.Dependencies.annotate_span}\pysiglinewithargsret{\bfcode{annotate\_span}}{\emph{labels}}{}
Annotate labels with their span, to make the
grammar unique.

\end{fulllineitems}

\index{argument\_list() (dependencies.Dependencies method)}

\begin{fulllineitems}
\phantomsection\label{dependencies:dependencies.Dependencies.argument_list}\pysiglinewithargsret{\bfcode{argument\_list}}{\emph{head\_span}}{}
return a list with spans of the head and
its arguments

\end{fulllineitems}

\index{branching\_factor() (dependencies.Dependencies method)}

\begin{fulllineitems}
\phantomsection\label{dependencies:dependencies.Dependencies.branching_factor}\pysiglinewithargsret{\bfcode{branching\_factor}}{\emph{b\_dict=\{\}}}{}
Compute the branching factor of all nodes in the
dependency tree. If an input dictionary is given,
update the branching factors in the dictionary with
the newly found branching factors.

\end{fulllineitems}

\index{checkroot() (dependencies.Dependencies method)}

\begin{fulllineitems}
\phantomsection\label{dependencies:dependencies.Dependencies.checkroot}\pysiglinewithargsret{\bfcode{checkroot}}{}{}
Check if dependencies form a tree by checking coverage
of the rootnote.

\end{fulllineitems}

\index{comp\_score() (dependencies.Dependencies method)}

\begin{fulllineitems}
\phantomsection\label{dependencies:dependencies.Dependencies.comp_score}\pysiglinewithargsret{\bfcode{comp\_score}}{}{}
Returns the percentage of words that is head
of another word, thereby giving a measure of
the level of compositionality of the parse

\end{fulllineitems}

\index{dependency\_labels() (dependencies.Dependencies method)}

\begin{fulllineitems}
\phantomsection\label{dependencies:dependencies.Dependencies.dependency_labels}\pysiglinewithargsret{\bfcode{dependency\_labels}}{}{}
Produces standard labels for spans according to the following scheme:
\begin{itemize}
\item {} 
label{[}(i,i+1){]} = HEAD         iff word i+1 is the head of the sentence

\item {} 
label{[}(i,j+1){]} = rel          iff there is a dependency relation rel(x, y) and wordspan(y) = (i,j+1)

\item {} 
label{[}(i,i+1){]} = rel-head iff there is a dependency relation rel(x,i+1) and word i+1 was not labelled by one of the previous conditions

\end{itemize}

\end{fulllineitems}

\index{find\_dependent() (dependencies.Dependencies method)}

\begin{fulllineitems}
\phantomsection\label{dependencies:dependencies.Dependencies.find_dependent}\pysiglinewithargsret{\bfcode{find\_dependent}}{\emph{relation}}{}
Find the depending word of a dependency relation using a regular
expression.

\end{fulllineitems}

\index{find\_dependent\_pos() (dependencies.Dependencies method)}

\begin{fulllineitems}
\phantomsection\label{dependencies:dependencies.Dependencies.find_dependent_pos}\pysiglinewithargsret{\bfcode{find\_dependent\_pos}}{\emph{relation}}{}
Find the position of the dependent of a dependency relation
using a regular expression.

\end{fulllineitems}

\index{find\_head() (dependencies.Dependencies method)}

\begin{fulllineitems}
\phantomsection\label{dependencies:dependencies.Dependencies.find_head}\pysiglinewithargsret{\bfcode{find\_head}}{\emph{relation}}{}
Find the head word of a dependency relation using a regular
expression.

\end{fulllineitems}

\index{find\_head\_pos() (dependencies.Dependencies method)}

\begin{fulllineitems}
\phantomsection\label{dependencies:dependencies.Dependencies.find_head_pos}\pysiglinewithargsret{\bfcode{find\_head\_pos}}{\emph{relation}}{}
Find the position of the head of a dependency relation
using a regular expression.

\end{fulllineitems}

\index{find\_relationtype() (dependencies.Dependencies method)}

\begin{fulllineitems}
\phantomsection\label{dependencies:dependencies.Dependencies.find_relationtype}\pysiglinewithargsret{\bfcode{find\_relationtype}}{\emph{relation}}{}
Find the type of a dependency relation using a
regular expression.

\end{fulllineitems}

\index{get\_comp\_spanrels() (dependencies.Dependencies method)}

\begin{fulllineitems}
\phantomsection\label{dependencies:dependencies.Dependencies.get_comp_spanrels}\pysiglinewithargsret{\bfcode{get\_comp\_spanrels}}{}{}
Create a dictionary of dependencies between word positions
and word spans. Go through the dependency dictionary, but
select only the relations that display compositionality
(i.e. no relations between words)

\end{fulllineitems}

\index{get\_span() (dependencies.Dependencies method)}

\begin{fulllineitems}
\phantomsection\label{dependencies:dependencies.Dependencies.get_span}\pysiglinewithargsret{\bfcode{get\_span}}{\emph{key}}{}
Recursively compute the span of a word. 
The span of a word is constituted by the minimum and
maximum position that can be reached from the word by
following the directed dependency arrows. The spans are
left exclusive and right inclusive. I.e. if positions
i and j are the minimum and maximum positions that can
be reached from a word, its span will be {[}i-1,j{]}. Every
word necessarily spans itself, a word at position i
without dependents will thus have span {[}i-1,i{]}.
The dependency from root to head of the sentence is not
considered.

\end{fulllineitems}

\index{label\_all() (dependencies.Dependencies method)}

\begin{fulllineitems}
\phantomsection\label{dependencies:dependencies.Dependencies.label_all}\pysiglinewithargsret{\bfcode{label\_all}}{}{}
Label all spans of the sentence.

\end{fulllineitems}

\index{labels() (dependencies.Dependencies method)}

\begin{fulllineitems}
\phantomsection\label{dependencies:dependencies.Dependencies.labels}\pysiglinewithargsret{\bfcode{labels}}{\emph{label\_type='basic'}}{}
Return labels of given type.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\textbf{type} -- describes which label\_type should be used. Options: all, basic or SAMT.

\end{description}\end{quote}

The default labeltype is basic.

\end{fulllineitems}

\index{percentage\_SAMT() (dependencies.Dependencies method)}

\begin{fulllineitems}
\phantomsection\label{dependencies:dependencies.Dependencies.percentage_SAMT}\pysiglinewithargsret{\bfcode{percentage\_SAMT}}{}{}
Compute how many spans were labelled by
an SAMT label.
:return:        number of spans, number of labelled spans

\end{fulllineitems}

\index{print\_deps() (dependencies.Dependencies method)}

\begin{fulllineitems}
\phantomsection\label{dependencies:dependencies.Dependencies.print_deps}\pysiglinewithargsret{\bfcode{print\_deps}}{}{}
Displaying function. Print all the
dependency relations in the dependency
parse.

\end{fulllineitems}

\index{print\_labels() (dependencies.Dependencies method)}

\begin{fulllineitems}
\phantomsection\label{dependencies:dependencies.Dependencies.print_labels}\pysiglinewithargsret{\bfcode{print\_labels}}{\emph{labels}}{}
Print out the contents of a dictionary
in a nice format.

\end{fulllineitems}

\index{print\_spans() (dependencies.Dependencies method)}

\begin{fulllineitems}
\phantomsection\label{dependencies:dependencies.Dependencies.print_spans}\pysiglinewithargsret{\bfcode{print\_spans}}{}{}
Displaying function. Print all
word\_spans of of the dependency parse.

\end{fulllineitems}

\index{reconstruct\_sentence() (dependencies.Dependencies method)}

\begin{fulllineitems}
\phantomsection\label{dependencies:dependencies.Dependencies.reconstruct_sentence}\pysiglinewithargsret{\bfcode{reconstruct\_sentence}}{\emph{sentence}}{}
Reconstruct the sentence corresponding to the 
dependency parse.
:return:        a list with the words of the sentence.

\end{fulllineitems}

\index{set\_dependencies() (dependencies.Dependencies method)}

\begin{fulllineitems}
\phantomsection\label{dependencies:dependencies.Dependencies.set_dependencies}\pysiglinewithargsret{\bfcode{set\_dependencies}}{\emph{dependency\_list}}{}
Read in a file and create a dictionary
with its dependencies using regular expressions.

\end{fulllineitems}

\index{set\_wordspans() (dependencies.Dependencies method)}

\begin{fulllineitems}
\phantomsection\label{dependencies:dependencies.Dependencies.set_wordspans}\pysiglinewithargsret{\bfcode{set\_wordspans}}{}{}
Compute the span of each word and store it in a
dictionary with word positions and a tuple that
represents their span as key and value, respectively.

\end{fulllineitems}

\index{spanrelations() (dependencies.Dependencies method)}

\begin{fulllineitems}
\phantomsection\label{dependencies:dependencies.Dependencies.spanrelations}\pysiglinewithargsret{\bfcode{spanrelations}}{\emph{rightbranching=False}, \emph{leftbranching=False}, \emph{interpunction=True}}{}
Create a dictionary with spanrelations that are `deeper' than the standard 
relations in the dependency parse, such that stepwise combining head and
arguments is allowed. Parameters rightbranching, leftbranching and interpunction
describe how exactly arguments and heads are allowed to combine.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\textbf{rightbranching} -- allow an argument to combine with the arguments one by one,
giving preference to arguments to the right.

\item {} 
\textbf{leftbranching} -- allow an arguments to combine with the head one by one,
giving preference to arguments to the left.

\item {} 
\textbf{interpunction} -- Take gaps in the dependency parse into account, by adding
extra relations in which the gap is already combined
with one of its left or right adjacing units.

\end{itemize}

\end{description}\end{quote}

If both left- and rightbranching are true, all combination orders are allowed.

\end{fulllineitems}

\index{textree() (dependencies.Dependencies method)}

\begin{fulllineitems}
\phantomsection\label{dependencies:dependencies.Dependencies.textree}\pysiglinewithargsret{\bfcode{textree}}{}{}
Print string that will generate a dependency tree in
pdf with package tikz-dependency.

\end{fulllineitems}

\index{update\_labels() (dependencies.Dependencies method)}

\begin{fulllineitems}
\phantomsection\label{dependencies:dependencies.Dependencies.update_labels}\pysiglinewithargsret{\bfcode{update\_labels}}{\emph{label\_dict}}{}
Update an inputted dictionary with
the labels from dependency object.

\end{fulllineitems}


\end{fulllineitems}

\index{demo() (in module dependencies)}

\begin{fulllineitems}
\phantomsection\label{dependencies:dependencies.demo}\pysiglinewithargsret{\code{dependencies.}\bfcode{demo}}{}{}
A demonstration of how the Dependencies class can be used.

\end{fulllineitems}



\chapter{file\_processing Module}
\label{file_processing:file-processing-module}\label{file_processing::doc}\label{file_processing:module-file_processing}\index{file\_processing (module)}
File\_processing is a module for processing sentences, alignments and treestructures.
It brings together the functions from the other classes, enabeling the user to apply the functions
using information from three files containing alingments, sentences and parses.
Explain the different possibilities of the class.
\index{ProcessConstituencies (class in file\_processing)}

\begin{fulllineitems}
\phantomsection\label{file_processing:file_processing.ProcessConstituencies}\pysiglinewithargsret{\strong{class }\code{file\_processing.}\bfcode{ProcessConstituencies}}{\emph{alignmentfile}, \emph{sentencefile}, \emph{treefile}, \emph{targetfile=False}}{}
Bases: {\hyperref[file_processing:file_processing.ProcessFiles]{\code{file\_processing.ProcessFiles}}}

Subclass adapted for constituencies

During initialization the files are loaded for reading. Allows to leaf empty
one of more files if they are not needed for functions that will be used
\index{all\_rules() (file\_processing.ProcessConstituencies method)}

\begin{fulllineitems}
\phantomsection\label{file_processing:file_processing.ProcessConstituencies.all_rules}\pysiglinewithargsret{\bfcode{all\_rules}}{\emph{max\_length=40}}{}
\end{fulllineitems}

\index{branching\_factor() (file\_processing.ProcessConstituencies method)}

\begin{fulllineitems}
\phantomsection\label{file_processing:file_processing.ProcessConstituencies.branching_factor}\pysiglinewithargsret{\bfcode{branching\_factor}}{\emph{max\_length=40}}{}
Compute the average branching factor of all head nodes
of the dependency parses or the corpus.
Can be restricted to a sentence length.

\end{fulllineitems}

\index{consistent\_labels() (file\_processing.ProcessConstituencies method)}

\begin{fulllineitems}
\phantomsection\label{file_processing:file_processing.ProcessConstituencies.consistent_labels}\pysiglinewithargsret{\bfcode{consistent\_labels}}{\emph{label\_type}, \emph{max\_length=40}}{}
Determines the consistency of a set of alignments with a type of labels
over the entire corpus.

\end{fulllineitems}

\index{relation\_count() (file\_processing.ProcessConstituencies method)}

\begin{fulllineitems}
\phantomsection\label{file_processing:file_processing.ProcessConstituencies.relation_count}\pysiglinewithargsret{\bfcode{relation\_count}}{\emph{max\_length}}{}
Counts occurences of all labels in the
constituent parse.

\end{fulllineitems}

\index{score\_all\_sentences() (file\_processing.ProcessConstituencies method)}

\begin{fulllineitems}
\phantomsection\label{file_processing:file_processing.ProcessConstituencies.score_all_sentences}\pysiglinewithargsret{\bfcode{score\_all\_sentences}}{\emph{rule\_function}, \emph{probability\_function}, \emph{prob\_function\_args}, \emph{label\_args}, \emph{max\_length=40}, \emph{scorefile='`}, \emph{treefile='`}}{}
\end{fulllineitems}

\index{texstring() (file\_processing.ProcessConstituencies method)}

\begin{fulllineitems}
\phantomsection\label{file_processing:file_processing.ProcessConstituencies.texstring}\pysiglinewithargsret{\bfcode{texstring}}{\emph{new}}{}
Output a texstring with the alignment, the constituency tree
and the alignment.

\end{fulllineitems}


\end{fulllineitems}

\index{ProcessDependencies (class in file\_processing)}

\begin{fulllineitems}
\phantomsection\label{file_processing:file_processing.ProcessDependencies}\pysiglinewithargsret{\strong{class }\code{file\_processing.}\bfcode{ProcessDependencies}}{\emph{alignmentfile}, \emph{sentencefile}, \emph{treefile}, \emph{targetfile=False}}{}
Bases: {\hyperref[file_processing:file_processing.ProcessFiles]{\code{file\_processing.ProcessFiles}}}

Subclass of ProcessFiles that is focussed on the specific
occasion in which trees are dependencies.

During initialization the files are loaded for reading. Allows to leaf empty
one of more files if they are not needed for functions that will be used
\index{all\_HATs() (file\_processing.ProcessDependencies method)}

\begin{fulllineitems}
\phantomsection\label{file_processing:file_processing.ProcessDependencies.all_HATs}\pysiglinewithargsret{\bfcode{all\_HATs}}{\emph{file\_name}, \emph{max\_length=40}}{}
Compute all HATs grammars, represent them as a dictionary and
and pickle {[}sentence\_nr, rootlabel, HATdict{]} to a file with 
the     provided name file\_name.

\end{fulllineitems}

\index{branching\_factor() (file\_processing.ProcessDependencies method)}

\begin{fulllineitems}
\phantomsection\label{file_processing:file_processing.ProcessDependencies.branching_factor}\pysiglinewithargsret{\bfcode{branching\_factor}}{\emph{max\_length}}{}
Compute the average branching factor of all head nodes
of the dependency parses or the corpus.
Can be restricted to a sentence length.

\end{fulllineitems}

\index{check\_consistency() (file\_processing.ProcessDependencies method)}

\begin{fulllineitems}
\phantomsection\label{file_processing:file_processing.ProcessDependencies.check_consistency}\pysiglinewithargsret{\bfcode{check\_consistency}}{\emph{sentence}, \emph{dep\_list}}{}
Check whether a list with dependencies is
consistent with a sentence, by comparing the words.
Some flexibility is allowed, to account for words
that are spelled differently. Return True if the
dependency parse contains no more than 3 words not
present in the sentence and False otherwise.

\end{fulllineitems}

\index{close\_all() (file\_processing.ProcessDependencies method)}

\begin{fulllineitems}
\phantomsection\label{file_processing:file_processing.ProcessDependencies.close_all}\pysiglinewithargsret{\bfcode{close\_all}}{}{}
Close all input files.

\end{fulllineitems}

\index{consistent\_labels() (file\_processing.ProcessDependencies method)}

\begin{fulllineitems}
\phantomsection\label{file_processing:file_processing.ProcessDependencies.consistent_labels}\pysiglinewithargsret{\bfcode{consistent\_labels}}{\emph{label\_type}, \emph{max\_length=40}}{}
Determines the consistency of a set of alignments with a type of labels
over the entire corpus.

\end{fulllineitems}

\index{percentage\_labelled() (file\_processing.ProcessDependencies method)}

\begin{fulllineitems}
\phantomsection\label{file_processing:file_processing.ProcessDependencies.percentage_labelled}\pysiglinewithargsret{\bfcode{percentage\_labelled}}{\emph{max\_length}, \emph{label\_type}}{}
Compute the percentage of the spans in the dictionary
that is labelled by a labelling method

\end{fulllineitems}

\index{print\_dict() (file\_processing.ProcessDependencies method)}

\begin{fulllineitems}
\phantomsection\label{file_processing:file_processing.ProcessDependencies.print_dict}\pysiglinewithargsret{\bfcode{print\_dict}}{\emph{dictionary}, \emph{filename}}{}
Print the contents of a dictionary
to a file.

\end{fulllineitems}

\index{relation\_count() (file\_processing.ProcessDependencies method)}

\begin{fulllineitems}
\phantomsection\label{file_processing:file_processing.ProcessDependencies.relation_count}\pysiglinewithargsret{\bfcode{relation\_count}}{\emph{max\_length}}{}
Counts occurences of all relations in dependency
parses of sentences shorter than max\_length.

\end{fulllineitems}

\index{relation\_percentage() (file\_processing.ProcessDependencies method)}

\begin{fulllineitems}
\phantomsection\label{file_processing:file_processing.ProcessDependencies.relation_percentage}\pysiglinewithargsret{\bfcode{relation\_percentage}}{\emph{all\_relations}, \emph{relations\_present}}{}
\end{fulllineitems}

\index{sample() (file\_processing.ProcessDependencies method)}

\begin{fulllineitems}
\phantomsection\label{file_processing:file_processing.ProcessDependencies.sample}\pysiglinewithargsret{\bfcode{sample}}{\emph{samplesize}, \emph{maxlength=False}, \emph{display=False}}{}
Create a sample of sentence from the inputted files.
Create a file with the sentences, and files with the
matching alignments, dependencies and targetsentences.
If display = True, create a texfile that can be ran
to give a visual representation of the selected sentences.
Return an array with the list of sentence numbers that
were selected.

\end{fulllineitems}

\index{score\_all\_sentences() (file\_processing.ProcessDependencies method)}

\begin{fulllineitems}
\phantomsection\label{file_processing:file_processing.ProcessDependencies.score_all_sentences}\pysiglinewithargsret{\bfcode{score\_all\_sentences}}{\emph{rule\_function}, \emph{probability\_function}, \emph{prob\_function\_args}, \emph{label\_args}, \emph{max\_length=40}, \emph{scorefile=False}, \emph{treefile=False}}{}
\end{fulllineitems}

\index{tex\_preamble() (file\_processing.ProcessDependencies method)}

\begin{fulllineitems}
\phantomsection\label{file_processing:file_processing.ProcessDependencies.tex_preamble}\pysiglinewithargsret{\bfcode{tex\_preamble}}{}{}
Print the pre-amble of a tex document in which both 
dependency parses and alignments are printed.

\end{fulllineitems}

\index{texstring() (file\_processing.ProcessDependencies method)}

\begin{fulllineitems}
\phantomsection\label{file_processing:file_processing.ProcessDependencies.texstring}\pysiglinewithargsret{\bfcode{texstring}}{\emph{new}}{}
Output a texstring with the alignment, the dependency
and the 
ew = alignment, sentence, dep

\end{fulllineitems}

\index{transform\_contents() (file\_processing.ProcessDependencies method)}

\begin{fulllineitems}
\phantomsection\label{file_processing:file_processing.ProcessDependencies.transform_contents}\pysiglinewithargsret{\bfcode{transform\_contents}}{\emph{value}}{}
Return a suitable string representation of
input

\end{fulllineitems}


\end{fulllineitems}

\index{ProcessFiles (class in file\_processing)}

\begin{fulllineitems}
\phantomsection\label{file_processing:file_processing.ProcessFiles}\pysiglinewithargsret{\strong{class }\code{file\_processing.}\bfcode{ProcessFiles}}{\emph{alignmentfile}, \emph{sentencefile}, \emph{treefile}, \emph{targetfile=False}}{}
Brings together all functions by enabling the user
to apply functions from the other classes to files
containing alignments, sentences and
dependency parses.

During initialization the files are loaded for reading. Allows to leaf empty
one of more files if they are not needed for functions that will be used
\index{close\_all() (file\_processing.ProcessFiles method)}

\begin{fulllineitems}
\phantomsection\label{file_processing:file_processing.ProcessFiles.close_all}\pysiglinewithargsret{\bfcode{close\_all}}{}{}
Close all input files.

\end{fulllineitems}

\index{consistent\_labels() (file\_processing.ProcessFiles method)}

\begin{fulllineitems}
\phantomsection\label{file_processing:file_processing.ProcessFiles.consistent_labels}\pysiglinewithargsret{\bfcode{consistent\_labels}}{\emph{label\_type}, \emph{max\_length=40}}{}
Determines the consistency of a set of alignments with a type of labels
over the entire corpus.

\end{fulllineitems}

\index{evaluate\_grammar() (file\_processing.ProcessFiles method)}

\begin{fulllineitems}
\phantomsection\label{file_processing:file_processing.ProcessFiles.evaluate_grammar}\pysiglinewithargsret{\bfcode{evaluate\_grammar}}{\emph{grammar}, \emph{max\_length}, \emph{scoref}}{}
Parse the corpus with inputted grammar and evaluate
how well the resulting parses cohere with the
alignments.

\end{fulllineitems}

\index{next() (file\_processing.ProcessFiles method)}

\begin{fulllineitems}
\phantomsection\label{file_processing:file_processing.ProcessFiles.next}\pysiglinewithargsret{\bfcode{next}}{}{}
Return the next alignment, sentence and tree\_list.
If the end of one of the files is reached, return False.

\end{fulllineitems}

\index{next\_sentence() (file\_processing.ProcessFiles method)}

\begin{fulllineitems}
\phantomsection\label{file_processing:file_processing.ProcessFiles.next_sentence}\pysiglinewithargsret{\bfcode{next\_sentence}}{}{}
Return the next sentence. If the end of the file is reached,
return None.

\end{fulllineitems}

\index{print\_dict() (file\_processing.ProcessFiles method)}

\begin{fulllineitems}
\phantomsection\label{file_processing:file_processing.ProcessFiles.print_dict}\pysiglinewithargsret{\bfcode{print\_dict}}{\emph{dictionary}, \emph{filename}}{}
Print the contents of a dictionary
to a file.

\end{fulllineitems}

\index{print\_function() (file\_processing.ProcessFiles method)}

\begin{fulllineitems}
\phantomsection\label{file_processing:file_processing.ProcessFiles.print_function}\pysiglinewithargsret{\bfcode{print\_function}}{\emph{to\_print}, \emph{filename}}{}
\end{fulllineitems}

\index{relation\_count() (file\_processing.ProcessFiles method)}

\begin{fulllineitems}
\phantomsection\label{file_processing:file_processing.ProcessFiles.relation_count}\pysiglinewithargsret{\bfcode{relation\_count}}{\emph{max\_length}}{}
Counts occurences of all relations in dependency
parses of sentences shorter than max\_length.

\end{fulllineitems}

\index{relation\_percentage() (file\_processing.ProcessFiles method)}

\begin{fulllineitems}
\phantomsection\label{file_processing:file_processing.ProcessFiles.relation_percentage}\pysiglinewithargsret{\bfcode{relation\_percentage}}{\emph{all\_relations}, \emph{relations\_present}}{}
\end{fulllineitems}

\index{score\_all\_sentences() (file\_processing.ProcessFiles method)}

\begin{fulllineitems}
\phantomsection\label{file_processing:file_processing.ProcessFiles.score_all_sentences}\pysiglinewithargsret{\bfcode{score\_all\_sentences}}{\emph{rule\_function}, \emph{probability\_function}, \emph{prob\_function\_args}, \emph{label\_args}, \emph{max\_length=40}, \emph{scorefile='`}, \emph{treefile='`}}{}
Not implemented in general class, use from more specific subclasses.
If not present, raise not implemented error.

\end{fulllineitems}

\index{transform\_contents() (file\_processing.ProcessFiles method)}

\begin{fulllineitems}
\phantomsection\label{file_processing:file_processing.ProcessFiles.transform_contents}\pysiglinewithargsret{\bfcode{transform\_contents}}{\emph{value}}{}
Return a suitable string representation of
input

\end{fulllineitems}


\end{fulllineitems}



\chapter{labelling Module}
\label{labelling::doc}\label{labelling:module-labelling}\label{labelling:labelling-module}\index{labelling (module)}\index{Labels (class in labelling)}

\begin{fulllineitems}
\phantomsection\label{labelling:labelling.Labels}\pysiglinewithargsret{\strong{class }\code{labelling.}\bfcode{Labels}}{\emph{labels}}{}
Class to create different kinds of labels from a set
of basic labels. Currently, some set of labels are
computed multiple times to be used in the computation
of other labels. Class can be made more efficient by storing
such sets of labels as attributes of the Labels instance.

Create a labelling object, with basic labels.
:param labels:  A dictionary assigning labels to spans
\index{SAMT\_labels() (labelling.Labels method)}

\begin{fulllineitems}
\phantomsection\label{labelling:labelling.Labels.SAMT_labels}\pysiglinewithargsret{\bfcode{SAMT\_labels}}{}{}
Return all SAMT labels based on the basic
labels of the object. The order if precedence is as follows:
\begin{itemize}
\item {} 
Basic labels

\item {} 
labels A + B, where A and B are basic labels;

\item {} 
labels A/B or AB where A and B are basic labels;

\item {} 
labels A + B + C where A,B and C are basic labels;

\end{itemize}

\end{fulllineitems}

\index{annotate\_span() (labelling.Labels method)}

\begin{fulllineitems}
\phantomsection\label{labelling:labelling.Labels.annotate_span}\pysiglinewithargsret{\bfcode{annotate\_span}}{\emph{labels}}{}
Annotate labels with their span, to make the
grammar unique.

\end{fulllineitems}

\index{concat() (labelling.Labels method)}

\begin{fulllineitems}
\phantomsection\label{labelling:labelling.Labels.concat}\pysiglinewithargsret{\bfcode{concat}}{\emph{depth}, \emph{o=\{\}}, \emph{i=None}}{}
Compute all concatenated labels up to inputted depth,
with basic labels i.
If an output dictionary o is passed, extend this dictionary
with the found spans that do not yet have a label in o.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\textbf{depth} -- The maximum number of variables in the labels.

\item {} 
\textbf{o} -- An output dictionary with already existing labels.

\item {} 
\textbf{i} -- A dictionary with basic labels to be concatenated.

\end{itemize}

\end{description}\end{quote}

\end{fulllineitems}

\index{label\_complexity() (labelling.Labels method)}

\begin{fulllineitems}
\phantomsection\label{labelling:labelling.Labels.label_complexity}\pysiglinewithargsret{\bfcode{label\_complexity}}{\emph{label}}{}
Return the number of variables in a label.

\end{fulllineitems}

\index{label\_most() (labelling.Labels method)}

\begin{fulllineitems}
\phantomsection\label{labelling:labelling.Labels.label_most}\pysiglinewithargsret{\bfcode{label\_most}}{}{}
Label all spans within the range of labels, following the following rules:
\begin{itemize}
\item {} 
Labels with a lower depth are always preferred;

\item {} 
Concatenated labels are preferred over minus and double/minus labels;

\item {} 
Single minus labels (with concatenated spans) are preferred over double minus labels.

\end{itemize}

SAMT labels thus have precedence over other labels.

\end{fulllineitems}

\index{minus() (labelling.Labels method)}

\begin{fulllineitems}
\phantomsection\label{labelling:labelling.Labels.minus}\pysiglinewithargsret{\bfcode{minus}}{\emph{depth}, \emph{o=\{\}}, \emph{i=None}}{}
Compute all labels of the form AB and B/A
where B is a basic label, and A a concatenated label that
contains no more than depth-1 variables.
If an output dictionary o is passed, extend this dictionary
with the found spans that do not yet have a label in o.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\textbf{depth} -- The maximum number of variables in the labels.

\item {} 
\textbf{o} -- An output dictionary that is to be updated with the new labels

\item {} 
\textbf{i} -- A dictionary with basic labels.

\end{itemize}

\end{description}\end{quote}

\end{fulllineitems}

\index{minus\_double() (labelling.Labels method)}

\begin{fulllineitems}
\phantomsection\label{labelling:labelling.Labels.minus_double}\pysiglinewithargsret{\bfcode{minus\_double}}{\emph{depth}, \emph{o=\{\}}, \emph{i=None}}{}
Compute all labels of the form AB/C, where 
A is a basic label, and B and C are concatenated
labels. The outputted labels have a number of variables
that is no higher than depth.
If an output dictionary o is passed, extend this dictionary
with the found spans that do not yet have a label in o.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\textbf{depth} -- The maximum number of variables in the labels.

\item {} 
\textbf{o} -- An output dictionary that is to be updated with the new labels

\item {} 
\textbf{i} -- A dictionary with basic labels.

\end{itemize}

\end{description}\end{quote}

Return a dictionary with all labels of the form
, where B is in self.labels or in i if i is provided,
and A and C are in A1 + A2 + An where A1.. An are in
self.labels or i and n \textless{}= depth.

\end{fulllineitems}


\end{fulllineitems}

\index{demo() (in module labelling)}

\begin{fulllineitems}
\phantomsection\label{labelling:labelling.demo}\pysiglinewithargsret{\code{labelling.}\bfcode{demo}}{}{}
\end{fulllineitems}



\chapter{dependencies Module}
\label{process_hats:dependencies-module}\label{process_hats::doc}\label{process_hats:module-process_hats}\index{process\_hats (module)}\index{HATGrammar (class in process\_hats)}

\begin{fulllineitems}
\phantomsection\label{process_hats:process_hats.HATGrammar}\pysiglinewithargsret{\strong{class }\code{process\_hats.}\bfcode{HATGrammar}}{\emph{HATdict}, \emph{root}}{}
Class that

Initialise with a dictionary uniquely representing a HAT
\index{plain\_label() (process\_hats.HATGrammar method)}

\begin{fulllineitems}
\phantomsection\label{process_hats:process_hats.HATGrammar.plain_label}\pysiglinewithargsret{\bfcode{plain\_label}}{\emph{label}}{}
strip the label from the part determining
its span, to make it uniform

\end{fulllineitems}

\index{probmass() (process\_hats.HATGrammar method)}

\begin{fulllineitems}
\phantomsection\label{process_hats:process_hats.HATGrammar.probmass}\pysiglinewithargsret{\bfcode{probmass}}{\emph{head\_node}, \emph{children=()}, \emph{external\_pcfg=\{\}}, \emph{probs=\{\}}}{}
Compute the probability mass of all subtrees headed by head\_node with
direct children children (possibly empty), given the input pcfg.

\end{fulllineitems}

\index{to\_WeightedGrammar() (process\_hats.HATGrammar method)}

\begin{fulllineitems}
\phantomsection\label{process_hats:process_hats.HATGrammar.to_WeightedGrammar}\pysiglinewithargsret{\bfcode{to\_WeightedGrammar}}{\emph{rule\_dict}, \emph{remove\_old=False}}{}
Transforms a set of rules represented in a
nested dictionary into a WeightedGrammar object.
It is assumed that the startsymbol of the grammar is 
TOP, if this is not the case, parsing with the grammar
is not possible.
If remove\_old = True, remove the old grammar during the
process to save memory.

\end{fulllineitems}

\index{update() (process\_hats.HATGrammar method)}

\begin{fulllineitems}
\phantomsection\label{process_hats:process_hats.HATGrammar.update}\pysiglinewithargsret{\bfcode{update}}{\emph{external\_pcfg}, \emph{probs}, \emph{grammar}, \emph{p\_cur}, \emph{lhs}}{}
Compute the updated counts for a node, given its parent
and how often this parent occurred in the forest.
Does not return a grammar, but modifies it globally.

\end{fulllineitems}

\index{update\_weights() (process\_hats.HATGrammar method)}

\begin{fulllineitems}
\phantomsection\label{process_hats:process_hats.HATGrammar.update_weights}\pysiglinewithargsret{\bfcode{update\_weights}}{\emph{grammar}, \emph{external\_pcfg=\{\}}}{}
Implicitly assign all HATs in the HATforest a probability,
normalise, and compute the counts of the rules in them
through relative frequency estimation.
Update the inputted grammar with these counts.

\end{fulllineitems}


\end{fulllineitems}

\index{ProcessHATs (class in process\_hats)}

\begin{fulllineitems}
\phantomsection\label{process_hats:process_hats.ProcessHATs}\pysiglinewithargsret{\strong{class }\code{process\_hats.}\bfcode{ProcessHATs}}{\emph{HATfile}}{}
Class with functions that can be applied to a file
containing pickled precomputed HATs.
ProcessHATs has functional overlap with the class
FileProcessing, but is more efficient as it avoids
recomputing HATforests.

Pass the name of the file containing the pickled
HATs.
\index{em() (process\_hats.ProcessHATs method)}

\begin{fulllineitems}
\phantomsection\label{process_hats:process_hats.ProcessHATs.em}\pysiglinewithargsret{\bfcode{em}}{\emph{max\_iter}}{}
When passing a grammar represented by a dictionary,
iteratively assign probabilities to all HATs of the
corpus and recompute the counts of the grammar with
relative frequency estimation until convergence or
until a maximum number iterations is reached.
Return the new grammar
:param start\_grammar    Grammar represented as a nested dictionary
:param max\_iter                 Maximum number of iterations
:param max\_length               Maximum sentence length considered

\end{fulllineitems}

\index{em\_iteration() (process\_hats.ProcessHATs method)}

\begin{fulllineitems}
\phantomsection\label{process_hats:process_hats.ProcessHATs.em_iteration}\pysiglinewithargsret{\bfcode{em\_iteration}}{\emph{old\_grammar}, \emph{new\_grammar}}{}
Assign probabilities to all HATs in the corpus with the
current grammar, recompute probabilities and return the
new grammar.
It is assumed that the HATs are precomputed and pickled into
a file in the correct order. Every sentence under max\_length should
be represented in the file as: {[}sentence\_nr, HAT\_dict, root{]}.

\end{fulllineitems}

\index{initialise\_grammar() (process\_hats.ProcessHATs method)}

\begin{fulllineitems}
\phantomsection\label{process_hats:process_hats.ProcessHATs.initialise_grammar}\pysiglinewithargsret{\bfcode{initialise\_grammar}}{}{}
Initialise a grammar based on all HATs in the corpus

\end{fulllineitems}

\index{next() (process\_hats.ProcessHATs method)}

\begin{fulllineitems}
\phantomsection\label{process_hats:process_hats.ProcessHATs.next}\pysiglinewithargsret{\bfcode{next}}{}{}
Return the next item in the file. If no 
:return {[}sentence\_nr, HATdict, root{]}

\end{fulllineitems}

\index{normalise() (process\_hats.ProcessHATs method)}

\begin{fulllineitems}
\phantomsection\label{process_hats:process_hats.ProcessHATs.normalise}\pysiglinewithargsret{\bfcode{normalise}}{\emph{rule\_dict}}{}
Given a nested dictionary that represent rules as follows:
\{lhs : \{rhs1 : count, rhs2: count ...\}, ....\}, return a
similar nested dictionary with normalised counts

\end{fulllineitems}

\index{unique\_rules() (process\_hats.ProcessHATs method)}

\begin{fulllineitems}
\phantomsection\label{process_hats:process_hats.ProcessHATs.unique_rules}\pysiglinewithargsret{\bfcode{unique\_rules}}{\emph{stepsize}}{}
Go through HATcorpus and keep track of the
percentage of the rules that is unique.
Store the number of rules and the number of unique
rules if the number of HATs processed \% stepsize is 0

\end{fulllineitems}


\end{fulllineitems}



\chapter{scoring Module}
\label{scoring:module-scoring}\label{scoring::doc}\label{scoring:scoring-module}\index{scoring (module)}\index{Scoring (class in scoring)}

\begin{fulllineitems}
\phantomsection\label{scoring:scoring.Scoring}\pysiglinewithargsret{\strong{class }\code{scoring.}\bfcode{Scoring}}{\emph{alignment}, \emph{sentence}, \emph{labels=\{\}}}{}
Class that provides methods for scoring an alignment according
to a set of preferred relations. The corresponding tree
is created, spanlabels can be entered to label the nodes
in the tree.

During initialization an alignment, a corresponding
sentence and a string with dependencies are passed.
A weighted CFG generating all HATs is created, the rules are
assigned `probabilities' according to preferred\_relations or
labels.
The adapted viterbi parser from the nltk toolkit is
used to parse the sentence and obtain the score.
\index{grammar() (scoring.Scoring method)}

\begin{fulllineitems}
\phantomsection\label{scoring:scoring.Scoring.grammar}\pysiglinewithargsret{\bfcode{grammar}}{\emph{rules}}{}
Return a weighted grammar (NLTK-style) and its rank
given a generator object with all rules.

\end{fulllineitems}

\index{grammar\_rank() (scoring.Scoring method)}

\begin{fulllineitems}
\phantomsection\label{scoring:scoring.Scoring.grammar_rank}\pysiglinewithargsret{\bfcode{grammar\_rank}}{\emph{rules}}{}
Determine the maximum rank of a set of rules.

\end{fulllineitems}

\index{list\_productions() (scoring.Scoring method)}

\begin{fulllineitems}
\phantomsection\label{scoring:scoring.Scoring.list_productions}\pysiglinewithargsret{\bfcode{list\_productions}}{\emph{rules}}{}
\end{fulllineitems}

\index{make\_lexdict() (scoring.Scoring method)}

\begin{fulllineitems}
\phantomsection\label{scoring:scoring.Scoring.make_lexdict}\pysiglinewithargsret{\bfcode{make\_lexdict}}{}{}
Create a dictionary assigning words to spans.

\end{fulllineitems}

\index{parse() (scoring.Scoring method)}

\begin{fulllineitems}
\phantomsection\label{scoring:scoring.Scoring.parse}\pysiglinewithargsret{\bfcode{parse}}{\emph{grammar}, \emph{trace=0}}{}
Parse the sentence with the given grammar
using the viterbi parser from the nltk.
Return the best parse and its score.

\end{fulllineitems}

\index{score() (scoring.Scoring method)}

\begin{fulllineitems}
\phantomsection\label{scoring:scoring.Scoring.score}\pysiglinewithargsret{\bfcode{score}}{\emph{rule\_function}, \emph{prob\_function}, \emph{args}, \emph{trace=0}}{}
Score, args are arguments for prob\_function.
Thus: if probfunction = Rule.probability\_labels, then args
should be {[}labels{]}, if it is Rule.probability\_spanrels then
args should be {[}spanrels, normalization\_factor{]}

\end{fulllineitems}

\index{transform\_to\_Production() (scoring.Scoring method)}

\begin{fulllineitems}
\phantomsection\label{scoring:scoring.Scoring.transform_to_Production}\pysiglinewithargsret{\bfcode{transform\_to\_Production}}{\emph{rule}}{}
Transform rule to Production object (NLTK-style)

\end{fulllineitems}

\index{transform\_to\_WeightedProduction() (scoring.Scoring method)}

\begin{fulllineitems}
\phantomsection\label{scoring:scoring.Scoring.transform_to_WeightedProduction}\pysiglinewithargsret{\bfcode{transform\_to\_WeightedProduction}}{\emph{rule}}{}
Transform Rule object to WeightedProduction object (NLTK-style)

\end{fulllineitems}


\end{fulllineitems}



\chapter{tests Module}
\label{tests:module-tests}\label{tests:tests-module}\label{tests::doc}\index{tests (module)}\index{Tests (class in tests)}

\begin{fulllineitems}
\phantomsection\label{tests:tests.Tests}\pysigline{\strong{class }\code{tests.}\bfcode{Tests}}~\index{test\_all() (tests.Tests method)}

\begin{fulllineitems}
\phantomsection\label{tests:tests.Tests.test_all}\pysiglinewithargsret{\bfcode{test\_all}}{}{}
\end{fulllineitems}


\end{fulllineitems}

\phantomsection\label{tests:module-tests_alignments}\index{tests\_alignments (module)}\index{AlignmentsTests (class in tests\_alignments)}

\begin{fulllineitems}
\phantomsection\label{tests:tests_alignments.AlignmentsTests}\pysigline{\strong{class }\code{tests\_alignments.}\bfcode{AlignmentsTests}}
Tests Alignments Module
\index{alignment\_test\_all() (tests\_alignments.AlignmentsTests method)}

\begin{fulllineitems}
\phantomsection\label{tests:tests_alignments.AlignmentsTests.alignment_test_all}\pysiglinewithargsret{\bfcode{alignment\_test\_all}}{}{}
\end{fulllineitems}

\index{consistency\_test1() (tests\_alignments.AlignmentsTests method)}

\begin{fulllineitems}
\phantomsection\label{tests:tests_alignments.AlignmentsTests.consistency_test1}\pysiglinewithargsret{\bfcode{consistency\_test1}}{}{}
\end{fulllineitems}

\index{consistency\_test2() (tests\_alignments.AlignmentsTests method)}

\begin{fulllineitems}
\phantomsection\label{tests:tests_alignments.AlignmentsTests.consistency_test2}\pysiglinewithargsret{\bfcode{consistency\_test2}}{}{}
\end{fulllineitems}

\index{consistency\_test3() (tests\_alignments.AlignmentsTests method)}

\begin{fulllineitems}
\phantomsection\label{tests:tests_alignments.AlignmentsTests.consistency_test3}\pysiglinewithargsret{\bfcode{consistency\_test3}}{}{}
\end{fulllineitems}

\index{dict\_test() (tests\_alignments.AlignmentsTests method)}

\begin{fulllineitems}
\phantomsection\label{tests:tests_alignments.AlignmentsTests.dict_test}\pysiglinewithargsret{\bfcode{dict\_test}}{}{}
Test the function Alignments.HAT\_dict()

\end{fulllineitems}

\index{span\_test1() (tests\_alignments.AlignmentsTests method)}

\begin{fulllineitems}
\phantomsection\label{tests:tests_alignments.AlignmentsTests.span_test1}\pysiglinewithargsret{\bfcode{span\_test1}}{}{}
Test if correct spans are found for
a monotone alignment with no unaligned words

\end{fulllineitems}

\index{span\_test2() (tests\_alignments.AlignmentsTests method)}

\begin{fulllineitems}
\phantomsection\label{tests:tests_alignments.AlignmentsTests.span_test2}\pysiglinewithargsret{\bfcode{span\_test2}}{}{}
Test if correct spans are found for a non 
monotone many-to-many alignment, with no
unaligned words on source nor targetside.

\end{fulllineitems}

\index{span\_test3() (tests\_alignments.AlignmentsTests method)}

\begin{fulllineitems}
\phantomsection\label{tests:tests_alignments.AlignmentsTests.span_test3}\pysiglinewithargsret{\bfcode{span\_test3}}{}{}
Test if correct spans are found for a 
one-to-one alignment with some
unaligned words on source and target side

\end{fulllineitems}

\index{span\_test4() (tests\_alignments.AlignmentsTests method)}

\begin{fulllineitems}
\phantomsection\label{tests:tests_alignments.AlignmentsTests.span_test4}\pysiglinewithargsret{\bfcode{span\_test4}}{}{}
Test if correct spans are found for 
a non monotone many-to-many alignment with
unaligned words on both and target side.

\end{fulllineitems}

\index{spans\_test\_all() (tests\_alignments.AlignmentsTests method)}

\begin{fulllineitems}
\phantomsection\label{tests:tests_alignments.AlignmentsTests.spans_test_all}\pysiglinewithargsret{\bfcode{spans\_test\_all}}{}{}
Return True if all span tests return True

\end{fulllineitems}


\end{fulllineitems}

\phantomsection\label{tests:module-tests_dependencies}\index{tests\_dependencies (module)}\index{DependencyTests (class in tests\_dependencies)}

\begin{fulllineitems}
\phantomsection\label{tests:tests_dependencies.DependencyTests}\pysigline{\strong{class }\code{tests\_dependencies.}\bfcode{DependencyTests}}~\index{allr\_test1() (tests\_dependencies.DependencyTests method)}

\begin{fulllineitems}
\phantomsection\label{tests:tests_dependencies.DependencyTests.allr_test1}\pysiglinewithargsret{\bfcode{allr\_test1}}{}{}
Test left branching relations for sentence `I give the boy some flowers'

\end{fulllineitems}

\index{allr\_test2() (tests\_dependencies.DependencyTests method)}

\begin{fulllineitems}
\phantomsection\label{tests:tests_dependencies.DependencyTests.allr_test2}\pysiglinewithargsret{\bfcode{allr\_test2}}{}{}
\end{fulllineitems}

\index{dependencies\_test\_all() (tests\_dependencies.DependencyTests method)}

\begin{fulllineitems}
\phantomsection\label{tests:tests_dependencies.DependencyTests.dependencies_test_all}\pysiglinewithargsret{\bfcode{dependencies\_test\_all}}{}{}
Run all dependency tests.

\end{fulllineitems}

\index{labels\_annotation\_test() (tests\_dependencies.DependencyTests method)}

\begin{fulllineitems}
\phantomsection\label{tests:tests_dependencies.DependencyTests.labels_annotation_test}\pysiglinewithargsret{\bfcode{labels\_annotation\_test}}{}{}
Test annotated labels for a manually constructed sentence

\end{fulllineitems}

\index{labels\_test1() (tests\_dependencies.DependencyTests method)}

\begin{fulllineitems}
\phantomsection\label{tests:tests_dependencies.DependencyTests.labels_test1}\pysiglinewithargsret{\bfcode{labels\_test1}}{}{}
Test functioning plain labelling for sentence
`I give the boy some flowers'

\end{fulllineitems}

\index{lr\_test() (tests\_dependencies.DependencyTests method)}

\begin{fulllineitems}
\phantomsection\label{tests:tests_dependencies.DependencyTests.lr_test}\pysiglinewithargsret{\bfcode{lr\_test}}{}{}
Test left branching relations for sentence `I give the boy some flowers'

\end{fulllineitems}

\index{rr\_test() (tests\_dependencies.DependencyTests method)}

\begin{fulllineitems}
\phantomsection\label{tests:tests_dependencies.DependencyTests.rr_test}\pysiglinewithargsret{\bfcode{rr\_test}}{}{}
Test right branching relations for sentence `I give the boy some flowers'

\end{fulllineitems}

\index{spanrelations\_test() (tests\_dependencies.DependencyTests method)}

\begin{fulllineitems}
\phantomsection\label{tests:tests_dependencies.DependencyTests.spanrelations_test}\pysiglinewithargsret{\bfcode{spanrelations\_test}}{}{}
Test if spanrelations are extracted correctly
from a list of dependencies

\end{fulllineitems}

\index{test\_all\_labels() (tests\_dependencies.DependencyTests method)}

\begin{fulllineitems}
\phantomsection\label{tests:tests_dependencies.DependencyTests.test_all_labels}\pysiglinewithargsret{\bfcode{test\_all\_labels}}{}{}
Test for label all function

\end{fulllineitems}

\index{test\_samt\_labels() (tests\_dependencies.DependencyTests method)}

\begin{fulllineitems}
\phantomsection\label{tests:tests_dependencies.DependencyTests.test_samt_labels}\pysiglinewithargsret{\bfcode{test\_samt\_labels}}{}{}
Test SAMT labels

\end{fulllineitems}


\end{fulllineitems}

\phantomsection\label{tests:module-tests_node}\index{tests\_node (module)}\index{NodeTests (class in tests\_node)}

\begin{fulllineitems}
\phantomsection\label{tests:tests_node.NodeTests}\pysigline{\strong{class }\code{tests\_node.}\bfcode{NodeTests}}
Tests functionality of Node class.
\index{path\_test1() (tests\_node.NodeTests method)}

\begin{fulllineitems}
\phantomsection\label{tests:tests_node.NodeTests.path_test1}\pysiglinewithargsret{\bfcode{path\_test1}}{}{}
Test if paths are computed as intended by
manually constructing a graph with 5 nodes
and a couple of edges. Output True if correct
paths are found, False otherwise.

\end{fulllineitems}

\index{path\_test2() (tests\_node.NodeTests method)}

\begin{fulllineitems}
\phantomsection\label{tests:tests_node.NodeTests.path_test2}\pysiglinewithargsret{\bfcode{path\_test2}}{}{}
Test if shortest paths are computed as intended 
by manually constructing a graph with 5 nodes
and a couple of edges. Output True if correct
paths are found, False otherwise.

\end{fulllineitems}

\index{path\_test3() (tests\_node.NodeTests method)}

\begin{fulllineitems}
\phantomsection\label{tests:tests_node.NodeTests.path_test3}\pysiglinewithargsret{\bfcode{path\_test3}}{}{}
Test if shortest paths are computed as intended 
by manually constructing a  fully connected
graph with 5 nodes. Output True if correct
paths are found, False otherwise.

\end{fulllineitems}

\index{path\_test\_all() (tests\_node.NodeTests method)}

\begin{fulllineitems}
\phantomsection\label{tests:tests_node.NodeTests.path_test_all}\pysiglinewithargsret{\bfcode{path\_test\_all}}{}{}
\end{fulllineitems}

\index{worst\_case\_test() (tests\_node.NodeTests method)}

\begin{fulllineitems}
\phantomsection\label{tests:tests_node.NodeTests.worst_case_test}\pysiglinewithargsret{\bfcode{worst\_case\_test}}{\emph{nr\_of\_nodes}}{}
Speed test for shortest\_paths\_to.
Create a fully connected graph with
nr\_of\_nodes nodes and compute the
shortest\_paths between all nodes.
Output running time.

\end{fulllineitems}


\end{fulllineitems}

\phantomsection\label{tests:module-tests_rule}\index{tests\_rule (module)}\index{RuleTests (class in tests\_rule)}

\begin{fulllineitems}
\phantomsection\label{tests:tests_rule.RuleTests}\pysigline{\strong{class }\code{tests\_rule.}\bfcode{RuleTests}}
Testing class for the rule class.
\index{rules\_test\_all() (tests\_rule.RuleTests method)}

\begin{fulllineitems}
\phantomsection\label{tests:tests_rule.RuleTests.rules_test_all}\pysiglinewithargsret{\bfcode{rules\_test\_all}}{}{}
Return True if all rule tests return True

\end{fulllineitems}

\index{test2() (tests\_rule.RuleTests method)}

\begin{fulllineitems}
\phantomsection\label{tests:tests_rule.RuleTests.test2}\pysiglinewithargsret{\bfcode{test2}}{}{}
\end{fulllineitems}

\index{test\_hatrules() (tests\_rule.RuleTests method)}

\begin{fulllineitems}
\phantomsection\label{tests:tests_rule.RuleTests.test_hatrules}\pysiglinewithargsret{\bfcode{test\_hatrules}}{}{}
Test if the correct HATgrammar is generated for
the sentence `My dog likes eating sausages',
with alignment `0-0 1-1 2-2 2-3 3-5 4-4'.

\end{fulllineitems}

\index{test\_hatrules2() (tests\_rule.RuleTests method)}

\begin{fulllineitems}
\phantomsection\label{tests:tests_rule.RuleTests.test_hatrules2}\pysiglinewithargsret{\bfcode{test\_hatrules2}}{}{}
Test if the correct HATgrammar is generated for
the sentence `My dog likes eating sausages',
with alignment `0-0 1-1 2-2 2-3 3-5 4-4'.

\end{fulllineitems}

\index{test\_rules() (tests\_rule.RuleTests method)}

\begin{fulllineitems}
\phantomsection\label{tests:tests_rule.RuleTests.test_rules}\pysiglinewithargsret{\bfcode{test\_rules}}{}{}
Test if the correct grammar is generated for
the sentence `My dog likes eating sausages',
with alignment `0-0 1-1 2-2 2-3 3-5 4-4'.

\end{fulllineitems}


\end{fulllineitems}

\phantomsection\label{tests:module-tests_scoring}\index{tests\_scoring (module)}\index{ScoreTests (class in tests\_scoring)}

\begin{fulllineitems}
\phantomsection\label{tests:tests_scoring.ScoreTests}\pysigline{\strong{class }\code{tests\_scoring.}\bfcode{ScoreTests}}
Test Scoring Class
\index{score\_test1() (tests\_scoring.ScoreTests method)}

\begin{fulllineitems}
\phantomsection\label{tests:tests_scoring.ScoreTests.score_test1}\pysiglinewithargsret{\bfcode{score\_test1}}{}{}
Sentence: `my dog likes eating sausage'
Alignment: `0-0 1-1 2-2 2-3 3-5 4-4'
Dependencies: `nsubj(likes-3, dog-2)', `root(ROOT-0, likes-3)',
`xcomp(likes-3, eating-4)' and `dobj(eating-4, sausages-5)'.

Manual score normal rules spanrels: 1.0
Manual score hatrules spanrels: 0.75
Manual score hatrules spanrels deep: 1.0

\end{fulllineitems}

\index{score\_test2() (tests\_scoring.ScoreTests method)}

\begin{fulllineitems}
\phantomsection\label{tests:tests_scoring.ScoreTests.score_test2}\pysiglinewithargsret{\bfcode{score\_test2}}{}{}
Sentence: `european growth is inconceivable without solidarity .'
Alignment: `0-0 1-1 2-2 3-3 4-4 5-5 6-6'
Dependencies: `nn(growth-2, european-1)', `nsubj(inconceivable-4, growth-2)',
`cop(inconceivable-4, is-3)', `root(ROOT-0, inconceivable-4)', 
`prep(inconceivable-4, without-5)' and `pobj(without-5, solidarity-6)'

Manual score all rules spanrels: 1.0
Manual score hat rules spanrels: 0.6
Manual score hat rules spanrels deep: 1.0

\end{fulllineitems}

\index{score\_test3() (tests\_scoring.ScoreTests method)}

\begin{fulllineitems}
\phantomsection\label{tests:tests_scoring.ScoreTests.score_test3}\pysiglinewithargsret{\bfcode{score\_test3}}{}{}
Sentence: `approval of the minutes of the previous sitting'
Alignment: `5-6 4-5 3-4 3-2 2-1 6-8 3-3 1-1 0-0 7-7'
Dependencies: `root(ROOT-0, approval-1)','prep(approval-1, of-2)', `det(minutes-4, the-3)','pobj(of-2, minutes-4)','prep(approval-1, of-5)','det(sitting-8, the-6)','amod(sitting-8, previous-7)','pobj(of-5, sitting-8)'

Manual score all rules spanrels: 0.59
Manual score hat rules spanrels: 0.57
Manual score hat rules spanrels deep: 1.0

\end{fulllineitems}

\index{score\_test4() (tests\_scoring.ScoreTests method)}

\begin{fulllineitems}
\phantomsection\label{tests:tests_scoring.ScoreTests.score_test4}\pysiglinewithargsret{\bfcode{score\_test4}}{}{}
Sentence: `resumption of the session'
Alignment: `3-3 2-2 1-1 0-0'
Dependencies: `root(ROOT-0, resumption-1)','prep(resumption-1, of-2)','det(session-4, the-3)','pobj(of-2, session-4)'

Manual score all rules spanrels: 1.0
Manual score hat rules spanrels: 1.0
Manual score hat rules spanrels deep: 1.0

\end{fulllineitems}

\index{score\_test5() (tests\_scoring.ScoreTests method)}

\begin{fulllineitems}
\phantomsection\label{tests:tests_scoring.ScoreTests.score_test5}\pysiglinewithargsret{\bfcode{score\_test5}}{}{}
no dependencies

\end{fulllineitems}

\index{score\_test6() (tests\_scoring.ScoreTests method)}

\begin{fulllineitems}
\phantomsection\label{tests:tests_scoring.ScoreTests.score_test6}\pysiglinewithargsret{\bfcode{score\_test6}}{}{}
dependencies form no tree

\end{fulllineitems}

\index{score\_test7() (tests\_scoring.ScoreTests method)}

\begin{fulllineitems}
\phantomsection\label{tests:tests_scoring.ScoreTests.score_test7}\pysiglinewithargsret{\bfcode{score\_test7}}{}{}
Test to check workings for interpunction.

\end{fulllineitems}

\index{score\_test8() (tests\_scoring.ScoreTests method)}

\begin{fulllineitems}
\phantomsection\label{tests:tests_scoring.ScoreTests.score_test8}\pysiglinewithargsret{\bfcode{score\_test8}}{}{}
Second interpunction check.

\end{fulllineitems}

\index{score\_test9() (tests\_scoring.ScoreTests method)}

\begin{fulllineitems}
\phantomsection\label{tests:tests_scoring.ScoreTests.score_test9}\pysiglinewithargsret{\bfcode{score\_test9}}{}{}
\end{fulllineitems}

\index{score\_test\_all() (tests\_scoring.ScoreTests method)}

\begin{fulllineitems}
\phantomsection\label{tests:tests_scoring.ScoreTests.score_test_all}\pysiglinewithargsret{\bfcode{score\_test\_all}}{}{}
\end{fulllineitems}


\end{fulllineitems}

\phantomsection\label{tests:module-tests_labelling}\index{tests\_labelling (module)}\index{LabelsTests (class in tests\_labelling)}

\begin{fulllineitems}
\phantomsection\label{tests:tests_labelling.LabelsTests}\pysigline{\strong{class }\code{tests\_labelling.}\bfcode{LabelsTests}}
Class to test functionality of the class Labels
\index{SAMT\_test() (tests\_labelling.LabelsTests method)}

\begin{fulllineitems}
\phantomsection\label{tests:tests_labelling.LabelsTests.SAMT_test}\pysiglinewithargsret{\bfcode{SAMT\_test}}{}{}
Test Labels.SAMT

\end{fulllineitems}

\index{base\_test() (tests\_labelling.LabelsTests method)}

\begin{fulllineitems}
\phantomsection\label{tests:tests_labelling.LabelsTests.base_test}\pysiglinewithargsret{\bfcode{base\_test}}{}{}
\end{fulllineitems}

\index{concat\_test() (tests\_labelling.LabelsTests method)}

\begin{fulllineitems}
\phantomsection\label{tests:tests_labelling.LabelsTests.concat_test}\pysiglinewithargsret{\bfcode{concat\_test}}{}{}
Test Labels.concat for different depths.

\end{fulllineitems}

\index{label\_all\_test() (tests\_labelling.LabelsTests method)}

\begin{fulllineitems}
\phantomsection\label{tests:tests_labelling.LabelsTests.label_all_test}\pysiglinewithargsret{\bfcode{label\_all\_test}}{}{}
Test Labels.label\_most()

\end{fulllineitems}

\index{minus\_double\_test() (tests\_labelling.LabelsTests method)}

\begin{fulllineitems}
\phantomsection\label{tests:tests_labelling.LabelsTests.minus_double_test}\pysiglinewithargsret{\bfcode{minus\_double\_test}}{}{}
Test Labels.minus\_double for different depths

\end{fulllineitems}

\index{minus\_test() (tests\_labelling.LabelsTests method)}

\begin{fulllineitems}
\phantomsection\label{tests:tests_labelling.LabelsTests.minus_test}\pysiglinewithargsret{\bfcode{minus\_test}}{}{}
Test Labels.minus for different depths

\end{fulllineitems}

\index{test\_all() (tests\_labelling.LabelsTests method)}

\begin{fulllineitems}
\phantomsection\label{tests:tests_labelling.LabelsTests.test_all}\pysiglinewithargsret{\bfcode{test\_all}}{}{}
\end{fulllineitems}


\end{fulllineitems}

\phantomsection\label{tests:module-tests_HATforest}\index{tests\_HATforest (module)}\index{HATsTests (class in tests\_HATforest)}

\begin{fulllineitems}
\phantomsection\label{tests:tests_HATforest.HATsTests}\pysigline{\strong{class }\code{tests\_HATforest.}\bfcode{HATsTests}}
Contains tests for the HATforest class.
\index{grammar\_test() (tests\_HATforest.HATsTests method)}

\begin{fulllineitems}
\phantomsection\label{tests:tests_HATforest.HATsTests.grammar_test}\pysiglinewithargsret{\bfcode{grammar\_test}}{}{}
Test function for Alignments.compute\_weights with span adjusted labels.

\end{fulllineitems}

\index{probs\_test() (tests\_HATforest.HATsTests method)}

\begin{fulllineitems}
\phantomsection\label{tests:tests_HATforest.HATsTests.probs_test}\pysiglinewithargsret{\bfcode{probs\_test}}{}{}
Test the function HATs.probmass()

\end{fulllineitems}

\index{test\_all() (tests\_HATforest.HATsTests method)}

\begin{fulllineitems}
\phantomsection\label{tests:tests_HATforest.HATsTests.test_all}\pysiglinewithargsret{\bfcode{test\_all}}{}{}
\end{fulllineitems}

\index{update\_test() (tests\_HATforest.HATsTests method)}

\begin{fulllineitems}
\phantomsection\label{tests:tests_HATforest.HATsTests.update_test}\pysiglinewithargsret{\bfcode{update\_test}}{}{}
Test the function HATs.update()

\end{fulllineitems}

\index{update\_test2() (tests\_HATforest.HATsTests method)}

\begin{fulllineitems}
\phantomsection\label{tests:tests_HATforest.HATsTests.update_test2}\pysiglinewithargsret{\bfcode{update\_test2}}{}{}
Test the function Alignments.update() with input PCFG

\end{fulllineitems}


\end{fulllineitems}



\chapter{Indices and tables}
\label{index:indices-and-tables}\begin{itemize}
\item {} 
\emph{genindex}

\item {} 
\emph{modindex}

\item {} 
\emph{search}

\end{itemize}


\renewcommand{\indexname}{Python Module Index}
\begin{theindex}
\def\bigletter#1{{\Large\sffamily#1}\nopagebreak\vspace{1mm}}
\bigletter{a}
\item {\texttt{alignments}}, \pageref{alignments:module-alignments}
\indexspace
\bigletter{c}
\item {\texttt{constituencies}}, \pageref{constituencies:module-constituencies}
\indexspace
\bigletter{d}
\item {\texttt{dependencies}}, \pageref{dependencies:module-dependencies}
\indexspace
\bigletter{f}
\item {\texttt{file\_processing}}, \pageref{file_processing:module-file_processing}
\indexspace
\bigletter{l}
\item {\texttt{labelling}}, \pageref{labelling:module-labelling}
\indexspace
\bigletter{p}
\item {\texttt{process\_hats}}, \pageref{process_hats:module-process_hats}
\indexspace
\bigletter{s}
\item {\texttt{scoring}}, \pageref{scoring:module-scoring}
\indexspace
\bigletter{t}
\item {\texttt{tests}}, \pageref{tests:module-tests}
\item {\texttt{tests\_alignments}}, \pageref{tests:module-tests_alignments}
\item {\texttt{tests\_dependencies}}, \pageref{tests:module-tests_dependencies}
\item {\texttt{tests\_HATforest}}, \pageref{tests:module-tests_HATforest}
\item {\texttt{tests\_labelling}}, \pageref{tests:module-tests_labelling}
\item {\texttt{tests\_node}}, \pageref{tests:module-tests_node}
\item {\texttt{tests\_rule}}, \pageref{tests:module-tests_rule}
\item {\texttt{tests\_scoring}}, \pageref{tests:module-tests_scoring}
\end{theindex}

\renewcommand{\indexname}{Index}
\printindex
\end{document}
